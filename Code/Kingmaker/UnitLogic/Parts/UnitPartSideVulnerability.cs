using System.Collections.Generic;
using System.Linq;
using JetBrains.Annotations;
using Kingmaker.EntitySystem;
using Kingmaker.RuleSystem.Rules.Starships;
using Kingmaker.UnitLogic.Mechanics;
using Kingmaker.Utility.DotNetExtensions;
using Newtonsoft.Json;
using StateHasher.Core;
using StateHasher.Core.Hashers;
using UnityEngine;

namespace Kingmaker.UnitLogic.Parts;

public class UnitPartSideVulnerability : BaseUnitPart, IHashable
{
	public class Entry : IHashable
	{
		[JsonProperty]
		public StarshipHitLocation ShipLocation { get; set; }

		[JsonProperty]
		public WarhammerCombatSide UnitSide { get; set; }

		public GameObject Marker { get; set; }

		public virtual Hash128 GetHash128()
		{
			Hash128 result = default(Hash128);
			StarshipHitLocation val = ShipLocation;
			result.Append(ref val);
			WarhammerCombatSide val2 = UnitSide;
			result.Append(ref val2);
			return result;
		}
	}

	[JsonProperty]
	private readonly Dictionary<string, Entry> m_Entries = new Dictionary<string, Entry>();

	public Entry Add(EntityFact sourceFact, StarshipHitLocation location)
	{
		Entry entry = new Entry
		{
			ShipLocation = location
		};
		m_Entries.Add(sourceFact.UniqueId, entry);
		return entry;
	}

	public Entry Add(EntityFact sourceFact, WarhammerCombatSide side, bool CanStack)
	{
		if (!CanStack && m_Entries.Count((KeyValuePair<string, Entry> p) => p.Value.UnitSide == side) != 0)
		{
			return null;
		}
		Entry entry = new Entry
		{
			UnitSide = side
		};
		m_Entries.Add(sourceFact.UniqueId, entry);
		return entry;
	}

	public void Remove(EntityFact sourceFact)
	{
		m_Entries.Remove(sourceFact.UniqueId);
		if (m_Entries.Empty())
		{
			RemoveSelf();
		}
	}

	public void Remove(EntityFact sourceFact, bool savePart)
	{
		m_Entries.Remove(sourceFact.UniqueId);
		if (!savePart && m_Entries.Empty())
		{
			RemoveSelf();
		}
	}

	public void CreateOpposite(EntityFact sourceFact, Entry side, bool destroyCurrent, bool canStack)
	{
		WarhammerCombatSide side2 = side.UnitSide switch
		{
			WarhammerCombatSide.Front => WarhammerCombatSide.Back, 
			WarhammerCombatSide.Back => WarhammerCombatSide.Front, 
			WarhammerCombatSide.Left => WarhammerCombatSide.Right, 
			WarhammerCombatSide.Right => WarhammerCombatSide.Left, 
			_ => WarhammerCombatSide.Front, 
		};
		Remove(sourceFact, savePart: true);
		Add(sourceFact, side2, canStack);
	}

	[CanBeNull]
	public Entry Get(EntityFact sourceFact)
	{
		return m_Entries.Get(sourceFact.UniqueId);
	}

	public override Hash128 GetHash128()
	{
		Hash128 result = default(Hash128);
		Hash128 val = base.GetHash128();
		result.Append(ref val);
		Dictionary<string, Entry> entries = m_Entries;
		if (entries != null)
		{
			int val2 = 0;
			foreach (KeyValuePair<string, Entry> item in entries)
			{
				Hash128 hash = default(Hash128);
				Hash128 val3 = StringHasher.GetHash128(item.Key);
				hash.Append(ref val3);
				Hash128 val4 = ClassHasher<Entry>.GetHash128(item.Value);
				hash.Append(ref val4);
				val2 ^= hash.GetHashCode();
			}
			result.Append(ref val2);
		}
		return result;
	}
}
